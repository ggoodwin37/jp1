//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// near term

- investigate build mode, being the secondary button mode that allows you to directly manipulate the level within designated hotspots.

- consider changing propagate logic such that you have to be standing on solid ground in order to push something. this is slightly more realistic and also increases the playability of blocks (now we can use them as one-way-doors, etc.)

- world layers

- should add a bunch more static blocks and simple enemy types for gits and shiggles.
  - background-oriented tiles.

- clouds in bg should drift on their own (not cities though).



//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// future

-player and creeps (and herds) should be able to step up small blocks. how hard is this to implement? it doesnt happen instantaneously. bounces shouldnt trigger. what about pushing crates, probably shouldnt be able to step up while pushing a crate (and that's impossible to implement well).
  - e.g.:
    creatureActor::onCollided(other) {
      if other.yExtent is within ONE_BLOCK, engage a special mode.
        actually that isn't good enough, we need to check overall extent, not just collider extent. can we do this with an offset'd call to ER?
      else do usual collision logic (bouncing, etc)
    creatureActor::handleInputOrMovementSignal {
      if special mode, consider forward input to mean "also apply upward velocity". counteract gravity.
      the "also" is important because we need to keep moving horiz to continue checking if we are done.


- implement the restricted rect version of EWorldView drawToContext for better perf while drawing blocks.
  - you already are culling to view rect in the main grid document drawer, but I think there's an optional separate version of the draw method that only updates a certain rect. then we can invalidate just specific parts of the screen when drawing/erasing, should make editing snappier (until the user pans/zooms).
  - postponing for now, manually calculating the region to redraw is not hard but kind of a pain in the ass. maybe a special case to handle drawing single blocks?

- core, low pri: handling of sprite and preset constants is pretty ugly. should make this more dynamic and compact.

- revisit how groups are instantiated/added to world and er. can probably be cleaned up, not essential.

- z-index? can we use depth buffer? do layers cover this?
  - (I think layers cover this)

- beams

- generator blocks?

- herds basic impl.

- possible perf improvement: shared spritestates for non-actor anim blocks. example: a big castle with lots of spikes. no sense spinning up an animstate and paying to update it for each spike if they are all identical anyways. this only works if they are supposed to be identically in sync. profile first to verify suspicion that this scenario is expensive. I think it adds like 2 or 3 ms to world update for a moderate-large number of spikes.
  - the implementation here may be simpler than I thought. If we just lazy-create a single instance of a AnimSpriteState then pass that to all spike blocks, we're done. Yay good design for sprite states being separate from blocks. should do the same for static blocks too, could be big memory savings.
     - but of course it isn't that simple because then you have to figure out an efficient way to update each shared instance only once. Currently SpriteStateUpdater wants to run on every block.
       - shared blocks have the concept of a master block, it's the only one that actually updates the shared spritestate.

- bonus/secret stars.

- obsessive: ER layer is pretty solid, but the next layer up (propagateMovement, gapCheck, bounce, collision, v/vIntrinsic/motive/motiveAccel) is goofy. when you fix one thing, two other things break. what is the Right design? can we get rid of all order dependencies? can we unify collision/bouncing?

- thoughts on items: maybe RL dpad button is "item button". items are on special pedestals throughout the level. when you pick up a new item, the old one takes its place on the pedestal (maybe dulled out a bit). once you have an item, you press RL to use it.
items: blaster, jetpack, throw grenade, key, magnet (allowing you to transport blocks). the mutual exclusivity is a big part of the equation. one limitation is that it isn't ergonomic to press both dpads at same time. can we simulate this at the dpad layer? there's some special mutual exclusivity logic in there, maybe that needs to be relaxed.



//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// edit. claim: investing in edit makes play exponentially more awesome.

- TODO: putting these way down here makes them lower priority but they are not so, should interleave.

- cut/copy/paste. for copy, you've been picturing this intelligent edge trimming algorithm, but we can probably do without that for now and just trust author to make convenient copies (which handles 95% of actual use cases). i.e. drop blocks not entirely in copy region.

- would be cool to have like 3 to 4 draw slots so I can rapidly choose between several presets, can be pre-pop'd too.
  - this feels a little less interesting now.

- undo stack

- edit mode should be able to handle negative world coords. this is stupid, and requires several workarounds later that need to be removed: have to start the edit camera way far from origin so level has room to go up or left. then we normalize everything on play-load, which is slow and probably not even necessary. if we could simply use negative coords in edit this would be so much simpler and faster. I know there are a few fmaxf's here and there, but what is the real reason we can't use negative coords? is it just because they are used as keys in a table? negatives probably work with that anyways.

- idea: what if edit mode allowed you to make custom/one-off block variants? This would be easily supported on play side. could lead to interesting experiments. also might be an easy way to make event editing easier (i.e. event config editable here). would work better with MRU up and running.
  - careful though, don't want to get into a situation where player has no idea what to expect from a given block, that's cheap.
