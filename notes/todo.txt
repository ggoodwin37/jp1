//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// near term

- events
  - stub in some hardcoded events to get world part done. I think the edit part is making you procrastinate.

- world layers

- should add a bunch more static blocks and simple enemy types for gits and shiggles.
  - background-oriented tiles.

- clouds in bg should drift on their own (not cities though).


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// future

- implement the restricted rect version of EWorldView drawToContext for better perf while drawing blocks.
  - you already are culling to view rect in the main grid document drawer, but I think there's an optional separate version of the draw method that only updates a certain rect. then we can invalidate just specific parts of the screen when drawing/erasing, should make editing snappier (until the user pans/zooms).
  - postponing for now, manually calculating the region to redraw is not hard but kind of a pain in the ass. maybe a special case to handle drawing single blocks?

- core, low pri: handling of sprite and preset constants is pretty ugly. should make this more dynamic and compact.

- revisit how groups are instantiated/added to world and er. can probably be cleaned up, not essential.

- z-index? can we use depth buffer? do layers cover this?
  - (I think layers cover this)

- beams

- generator blocks?

- herds basic impl.

- possible perf improvement: shared spritestates for non-actor anim blocks. example: a big castle with lots of spikes. no sense spinning up an animstate and paying to update it for each spike if they are all identical anyways. this only works if they are supposed to be identically in sync. profile first to verify suspicion that this scenario is expensive. I think it adds like 2 or 3 ms to world update for a moderate-large number of spikes.
  - the implementation here may be simpler than I thought. If we just lazy-create a single instance of a AnimSpriteState then pass that to all spike blocks, we're done. Yay good design for sprite states being separate from blocks. should do the same for static blocks too, could be big memory savings.
     - but of course it isn't that simple because then you have to figure out an efficient way to update each shared instance only once. Currently SpriteStateUpdater wants to run on every block.
       - shared blocks have the concept of a master block, it's the only one that actually updates the shared spritestate.

- obsessive: ER layer is pretty solid, but the next layer up (propagateMovement, gapCheck, bounce, collision, v/vIntrinsic/motive/motiveAccel) is goofy. when you fix one thing, two other things break. what is the Right design? can we get rid of all order dependencies? can we unify collision/bouncing?

- thoughts on items: maybe RL dpad button is "item button". items are on special pedestals throughout the level. when you pick up a new item, the old one takes its place on the pedestal (maybe dulled out a bit). once you have an item, you press RL to use it.
items: blaster, jetpack, throw grenade, key, magnet (allowing you to transport blocks). the mutual exclusivity is a big part of the equation. one limitation is that it isn't ergonomic to press both dpads at same time. can we simulate this at the dpad layer? there's some special mutual exclusivity logic in there, maybe that needs to be relaxed.

- bonus/secret stars (see log.txt for more)

- vector graphics (see log)

- revisit build mode. I think we need a global button to exit build mode. test ergonomics of this.

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// edit. claim: investing in edit makes play exponentially more awesome.

- TODO: putting these way down here makes them lower priority but they are not so, should interleave.

- cut/copy/paste. for copy, you've been picturing this intelligent edge trimming algorithm, but we can probably do without that for now and just trust author to make convenient copies (which handles 95% of actual use cases). i.e. drop blocks not entirely in copy region.

- would be cool to have like 3 to 4 draw slots so I can rapidly choose between several presets, can be pre-pop'd too.
  - this feels a little less interesting now.

- undo stack

- edit mode should be able to handle negative world coords. this is stupid, and requires several workarounds later that need to be removed: have to start the edit camera way far from origin so level has room to go up or left. then we normalize everything on play-load, which is slow and probably not even necessary. if we could simply use negative coords in edit this would be so much simpler and faster. I know there are a few fmaxf's here and there, but what is the real reason we can't use negative coords? is it just because they are used as keys in a table? negatives probably work with that anyways.

- idea: what if edit mode allowed you to make custom/one-off block variants? This would be easily supported on play side. could lead to interesting experiments. also might be an easy way to make event editing easier (i.e. event config editable here). would work better with MRU up and running.
  - careful though, don't want to get into a situation where player has no idea what to expect from a given block, that's cheap.
